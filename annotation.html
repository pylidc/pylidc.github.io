
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Annotation &#8212; pylidc  documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Contour" href="contour.html" />
    <link rel="prev" title="Scan" href="scan.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="contour.html" title="Contour"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="Scan"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pylidc  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="annotation">
<h1>Annotation<a class="headerlink" href="#annotation" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pylidc.Annotation">
<em class="property">class </em><code class="descclassname">pylidc.</code><code class="descname">Annotation</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>The Nodule model class holds the information from a single physicians
annotation of a nodule &gt;= 3mm class with a particular scan. A nodule
has many contours, each of which refers to the contour drawn for
nodule in each scan slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>subtlety</strong> (<em>int</em>) – blah</li>
<li><strong>internalStructure</strong> (<em>int</em>) – blah</li>
<li><strong>calcification</strong> (<em>int</em>) – blah</li>
<li><strong>sphericity</strong> (<em>int</em>) – blah</li>
<li><strong>margin</strong> (<em>int</em>) – blah</li>
<li><strong>lobulation</strong> (<em>int</em>) – blah</li>
<li><strong>spiculation</strong> (<em>int</em>) – blah</li>
<li><strong>texture</strong> (<em>int</em>) – blah</li>
<li><strong>malignancy</strong> (<em>int</em>) – blah</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">import pylidc as pl
# Get the first annotation with spiculation value greater than 3.
ann = pl.query(pl.Annotation).filter(pl.Annotation.spiculation &gt; 3).first()</p>
<p>print(ann.spiculation)
# =&gt; 4</p>
<p># Each nodule feature has a corresponding property
# to print the semantic value.
print(ann.Spiculation)
# =&gt; Medium-High Spiculation</p>
<p>q = pl.query(pl.Annotation).join(pl.Scan)
q = q.filter(pl.Scan.slice_thickness &lt;= 1,</p>
<blockquote>
<div>pl.Annotation.malignancy == 5)</div></blockquote>
<p>print(q.count())
# =&gt; 58</p>
<p class="last">ann = q.first()
print(“%.2f, %.2f, %.2f” % (ann.diameter, ann.surface_area, ann.volume))
# =&gt; 17.98, 1221.40, 1033.70</p>
</dd>
</dl>
<dl class="attribute">
<dt id="pylidc.Annotation.Calcification">
<code class="descname">Calcification</code><a class="headerlink" href="#pylidc.Annotation.Calcification" title="Permalink to this definition">¶</a></dt>
<dd><p>return calcification value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.InternalStructure">
<code class="descname">InternalStructure</code><a class="headerlink" href="#pylidc.Annotation.InternalStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>return internalStructure value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Lobulation">
<code class="descname">Lobulation</code><a class="headerlink" href="#pylidc.Annotation.Lobulation" title="Permalink to this definition">¶</a></dt>
<dd><p>return lobulation value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Malignancy">
<code class="descname">Malignancy</code><a class="headerlink" href="#pylidc.Annotation.Malignancy" title="Permalink to this definition">¶</a></dt>
<dd><p>return malignancy value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Margin">
<code class="descname">Margin</code><a class="headerlink" href="#pylidc.Annotation.Margin" title="Permalink to this definition">¶</a></dt>
<dd><p>return margin value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Sphericity">
<code class="descname">Sphericity</code><a class="headerlink" href="#pylidc.Annotation.Sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>return sphericity value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Spiculation">
<code class="descname">Spiculation</code><a class="headerlink" href="#pylidc.Annotation.Spiculation" title="Permalink to this definition">¶</a></dt>
<dd><p>return spiculation value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Subtlety">
<code class="descname">Subtlety</code><a class="headerlink" href="#pylidc.Annotation.Subtlety" title="Permalink to this definition">¶</a></dt>
<dd><p>return subtlety value as string</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.Texture">
<code class="descname">Texture</code><a class="headerlink" href="#pylidc.Annotation.Texture" title="Permalink to this definition">¶</a></dt>
<dd><p>return texture value as string</p>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.bbox">
<code class="descname">bbox</code><span class="sig-paren">(</span><em>pad=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.bbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of Python <cite>slice</cite> objects that can be used to index
into the image volume corresponding to the extent of the
(padded) bounding box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pad</strong> (<em>int</em><em>, </em><em>list of ints</em><em>, or </em><em>float</em><em>, </em><em>default=None</em>) – <ul>
<li>If None (default), then no padding is used.</li>
<li>If an integer is provided, then the slices are padded
uniformly by this integer amount.</li>
<li><dl class="first docutils">
<dt>If a list of integers is provided, then it is of the form</dt>
<dd><cite>[(i1,i2), (j1,j2), (k1,k2)]</cite></dd>
</dl>
<p>and indicates the pad amounts along each coordinate axis.</p>
</li>
<li>If a float is provided, then the slices are padded such
that the bounding box occupies at least <cite>pad</cite> physical units
(using the corresponding scan <cite>pixel_spacing</cite> and <cite>slice_spacing</cite>
parameters). This means the returned Slice indices will
yield a bounding box that is at least <cite>pad</cite> millimeters along
each coordinate axis direction.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the various <cite>pad</cite> cases above, borders are handled so that if a
pad beyond the image borders is requested, then it is set
to the maximum (or minimum, depending on the direction)
possible index.</p>
</div>
<p class="rubric">Examples</p>
<p>The example below illustrates the various <cite>pad</cite> argument types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pylidc</span> <span class="k">as</span> <span class="nn">pl</span>

<span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">vol</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">to_volume</span><span class="p">()</span>

<span class="nb">print</span> <span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="c1"># =&gt; (slice(151, 185, None), slice(349, 376, None), slice(44, 50, None))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">()]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># =&gt; (34, 27, 6)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># =&gt; (38, 31, 10)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)])]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># =&gt; (37, 30, 12)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox_dims</span><span class="p">()))</span>
<span class="c1"># =&gt; 21.45</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">30.0</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># =&gt; (48, 49, 12)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">bbox_dims</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">30.0</span><span class="p">))</span>
<span class="c1"># =&gt; [30.55, 31.200000000000003, 33.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.bbox_dims">
<code class="descname">bbox_dims</code><span class="sig-paren">(</span><em>pad=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.bbox_dims"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.bbox_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the physical dimensions of the nodule bounding box in mm.</p>
<dl class="docutils">
<dt>pad: int, list, or float, default=None</dt>
<dd>See <a class="reference internal" href="#pylidc.Annotation.bbox" title="pylidc.Annotation.bbox"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pylidc.Annotation.bbox()</span></code></a> for a
description of this argument.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.bbox_matrix">
<code class="descname">bbox_matrix</code><span class="sig-paren">(</span><em>pad=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.bbox_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.bbox_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>bbox</cite> function returns a tuple of slices to be used to index
into an image volume. On the other hand, <cite>bbox_array</cite> returns
a 3x2 matrix where each row is the (start, stop) indices of the
i, j, and k axes.</p>
<dl class="docutils">
<dt>pad: int, list, or float</dt>
<dd>See <cite>Annotation.bbox</cite> for description of this argument.</dd>
<dt>NOTE: The indices return by <cite>bbox_array</cite> are <em>inclusive</em>, whereas</dt>
<dd>the indices of the slice objects in the tuple return by <cite>bbox</cite>
are offset by +1 in the “stop” index.</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pylidc</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bm</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">bbox_matrix</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">bm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">bm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.boolean_mask">
<code class="descname">boolean_mask</code><span class="sig-paren">(</span><em>pad=None</em>, <em>bbox=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.boolean_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.boolean_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean volume where 1 indicates nodule and 0 indicates
non-nodule. The <cite>mask</cite> volume covers the extent of the voxels
in the image volume given by <cite>annotation.bbox</cite>, i.e., the <cite>mask</cite>
volume would be placed in the full image volume according to
the <cite>bbox</cite> attribute.</p>
<dl class="docutils">
<dt>pad: int, list, or float, default=None</dt>
<dd>See <cite>Annotation.bbox</cite> for description of this argument.</dd>
<dt>bbox: 3x2 NumPy array, default=None</dt>
<dd>If <cite>bbox</cite> is provided, then <cite>pad</cite> is ignored. This argument allows
for more fine-tuned control of placement of the mask in a volume,
or for pre-computation of bbox when working with multiple
Annotation object.</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pylidc</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vol</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">to_volume</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Avg HU inside nodule: </span><span class="si">%.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">vol</span><span class="p">[</span><span class="n">bbox</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; Avg HU inside nodule: -280.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Avg HU outside nodule: </span><span class="si">%.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">vol</span><span class="p">[</span><span class="n">bbox</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; Avg HU outside nodule: -732.2</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#pylidc.Annotation.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the center of mass of the nodule as determined by its
radiologist-drawn contours.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pylidc</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vol</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">to_volume</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">vol</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;.r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Nodule centroid&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.contour_slice_indices">
<code class="descname">contour_slice_indices</code><a class="headerlink" href="#pylidc.Annotation.contour_slice_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of indices into the scan where each contour
belongs. An example should clarify:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pylidc</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zvals</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">contour_slice_zvals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kvals</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">contour_slice_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scan_zvals</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">slice_zvals</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kvals</span><span class="p">,</span> <span class="n">zvals</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># the two z values should the same (up to machine precision)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">scan_zvals</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.contour_slice_zvals">
<code class="descname">contour_slice_zvals</code><a class="headerlink" href="#pylidc.Annotation.contour_slice_zvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of unique z-coordinates for the contours.</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.contours_matrix">
<code class="descname">contours_matrix</code><a class="headerlink" href="#pylidc.Annotation.contours_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the contours in a 3D numpy array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.diameter">
<code class="descname">diameter</code><a class="headerlink" href="#pylidc.Annotation.diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the greatest axial plane diameter using the annotation’s
contours. This estimation does not currently account for cases
where the diamter passes outside the boundary of the nodule, or
through cavities within the nodule.</p>
<dl class="docutils">
<dt>returns: float (or float,Contour)</dt>
<dd>Returns the diameter as float, accounting for the axial-plane
resolution of the scan. The units are mm.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.feature_vals">
<code class="descname">feature_vals</code><span class="sig-paren">(</span><em>return_str=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.feature_vals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.feature_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all feature values as a numpy array in the order
presented in <cite>feature_names</cite>.</p>
<dl class="docutils">
<dt>return_str: bool, default False</dt>
<dd>If True, a list of strings is also returned, corresponding
to the meaning of each numerical feature value.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.print_formatted_feature_table">
<code class="descname">print_formatted_feature_table</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.print_formatted_feature_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.print_formatted_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all feature values as a string table.</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.surface_area">
<code class="descname">surface_area</code><a class="headerlink" href="#pylidc.Annotation.surface_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surface area by summing the areas of a trianglation
of the nodules surface in 3d. Returned units are mm^2.</p>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.uniform_cubic_resample">
<code class="descname">uniform_cubic_resample</code><span class="sig-paren">(</span><em>side_length=None</em>, <em>resample_vol=True</em>, <em>irp_pts=None</em>, <em>return_irp_pts=False</em>, <em>resample_img=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.uniform_cubic_resample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.uniform_cubic_resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the CT value volume and respective boolean mask volume. The
volumes are interpolated and resampled to have uniform spacing of 1mm
along each dimension. The resulting volumes are cubic of the
specified <cite>side_length</cite>. Thus, the returned volumes have dimensions,
<cite>(side_length+1,)*3</cite> (since <cite>side_length</cite> is the spacing).</p>
<dl class="docutils">
<dt>side_length: integer, default None</dt>
<dd><p class="first">The physical length of each side of the new cubic
volume in millimeters. The default, <cite>None</cite>, takes the
max of the nodule’s bounding box dimensions.</p>
<p class="last">If this parameter is not <cite>None</cite>, then it should be
greater than any bounding box dimension. If the specified
<cite>side_length</cite> requires a padding which results in an
out-of-bounds image index, then the image is padded with
the minimum CT image value.</p>
</dd>
<dt>resample_vol: boolean, default True</dt>
<dd>If False, only the segmentation volume is resampled.</dd>
<dt>irp_pts: 3-tuple from meshgrid</dt>
<dd>If provided, the volume(s) will be resampled over these interpolation
points, rather than the automatically calculated points. This allows
for sampling segmentation volumes over a common coordinate-system.</dd>
<dt>return_irp_pts: boolean, default False</dt>
<dd>If True, the interpolation points (ix,iy,iz) at which the volume(s)
were resampled are returned. These can potentially be provided as
an argument to <cite>irp_pts</cite> for separate selfotations that refer to the
same nodule, allowing the segmentation volumes to be resampled in a
common coordinate-system.</dd>
<dt>verbose: boolean, default True</dt>
<dd>Turn the loading statement on / off.</dd>
<dt>returns: [ct_volume,] mask [, irp_pts]</dt>
<dd><cite>ct_volume</cite> and <cite>mask</cite> are the resampled CT and boolean
volumes, respectively. <cite>ct_volume</cite> and <cite>irp_points</cite> are optionally
returned, depending on which flags are set (see above).</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct_volume</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">uniform_cubic_resample</span><span class="p">(</span><span class="n">side_length</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ct_volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; (71, 71, 71), (71, 71, 71)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># (Nodule is centered at (35,35,35).)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span> <span class="n">ct_volume</span><span class="p">[:,:,</span><span class="mi">35</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.2</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">mask</span><span class="p">[:,:,</span><span class="mi">35</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.visualize_in_3d">
<code class="descname">visualize_in_3d</code><span class="sig-paren">(</span><em>edgecolor='0.2'</em>, <em>cmap='viridis'</em>, <em>step=1</em>, <em>figsize=(5</em>, <em>5)</em>, <em>backend='matplotlib'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.visualize_in_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.visualize_in_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize in 3d a triangulation of the nodule’s surface.</p>
<dl class="docutils">
<dt>edgecolor: string color or rgb 3-tuple</dt>
<dd>Sets edgecolors of triangulation.
Ignored if backend != matplotlib.</dd>
<dt>cmap: matplotlib colormap string.</dt>
<dd>Sets the facecolors of the triangulation.
See <cite>matplotlib.cm.cmap_d.keys()</cite> for all available.
Ignored if backend != matplotlib.</dd>
<dt>step: int, default=1</dt>
<dd>The <cite>step_size</cite> parameter for the skimage marching_cubes function.
Bigger values are quicker, but yield coarser surfaces.</dd>
<dt>figsize: tuple, default=(5,5)</dt>
<dd>Figure size for the displayed volume.</dd>
<dt>backend: string</dt>
<dd>The backend for visualization. Default is matplotlib.
Execute <cite>from pylidc.Annotation import viz3dbackends</cite> to
see available backends.</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span><span class="o">.</span><span class="n">visualize_in_3d</span><span class="p">(</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;autumn&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ann</span><span class="o">.</span><span class="n">visualize_in_3d</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;mayavi&#39;</span><span class="p">)</span> <span class="c1"># If mayavi available.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pylidc.Annotation.visualize_in_scan">
<code class="descname">visualize_in_scan</code><span class="sig-paren">(</span><em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pylidc/Annotation.html#Annotation.visualize_in_scan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pylidc.Annotation.visualize_in_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactive visualization of the slices of the scan along with scan
and annotation information. The visualization begins
(but is not limited to) the first slice where the nodule occurs
(according to the annotation). Contours are plotted atop the images
for visualization and can be toggled on and off.</p>
</dd></dl>

<dl class="attribute">
<dt id="pylidc.Annotation.volume">
<code class="descname">volume</code><a class="headerlink" href="#pylidc.Annotation.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the volume of the annotated nodule, using the contour
annotations. Green’s theorem (via the shoelace formula) is first
used to measure the area in each slice. This area is multiplied
by the distance between slices to obtain a volume for each slice,
which is then added or subtracted from the total volume, depending
on if the inclusion value for the contour.</p>
<p>The distance between slices is taken to be the distance from the
midpoint between the current <cite>image_z_position</cite> and the
<cite>image_z_position</cite> in one slice higher plus the midpoint between
the current <cite>image_z_position</cite> and the <cite>image_z_position</cite> of one
slice below. If the the <cite>image_z_position</cite> corresponds to an end
piece, we use the distance between the current <cite>image_z_posiition</cite>
and the <cite>image_z_position</cite> of one slice below or above for top or
bottom, respectively. If the annotation only has one contour, we
use the <cite>slice_thickness</cite> attribute of the scan.</p>
<dl class="docutils">
<dt>returns: float</dt>
<dd>The estimated 3D volume of the annotated nodule. Units are mm^3.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation and setup</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tuts/scan.html">The Scan class</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuts/annotation.html">The Annotation class</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuts/consensus.html">Consolidation of multiple annotations of a single nodule</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="scan.html">Scan</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Annotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contour.html">Contour</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="scan.html"
                        title="previous chapter">Scan</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="contour.html"
                        title="next chapter">Contour</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/annotation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="contour.html" title="Contour"
             >next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="Scan"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pylidc  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Matt Hancock.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>